use std::collections::BTreeMap;
use std::collections::VecDeque;
use std::string::ToString;
use std::{fs, io::Write};

use egui_states_core::types::ObjectType;

use crate::State;
use crate::build_script::scripts;
use crate::build_script::state_creator::StatesCreatorBuild;
use crate::build_script::values_info::{InitValue, StateType};

fn type_to_pytype(type_info: &ObjectType) -> String {
    match type_info {
        ObjectType::U8 => "u8".to_string(),
        ObjectType::U16 => "u16".to_string(),
        ObjectType::U32 => "u32".to_string(),
        ObjectType::U64 => "u64".to_string(),
        ObjectType::I8 => "i8".to_string(),
        ObjectType::I16 => "i16".to_string(),
        ObjectType::I32 => "i32".to_string(),
        ObjectType::I64 => "i64".to_string(),
        ObjectType::F32 => "f32".to_string(),
        ObjectType::F64 => "f64".to_string(),
        ObjectType::Bool => "bo".to_string(),
        ObjectType::String => "st".to_string(),
        ObjectType::Empty => "emp".to_string(),
        ObjectType::Enum(name, _) => format!("enu({})", name),
        ObjectType::Struct(name, _) => format!("str({})", name),
        ObjectType::Tuple(vec) => {
            let elems: Vec<String> = vec.iter().map(|t| type_to_pytype(t)).collect();
            format!("tu([{}])", elems.join(", "))
        }
        ObjectType::List(size, element) => {
            format!("li({}, {})", type_to_pytype(element), size)
        }
        ObjectType::Vec(element) => {
            format!("vec({})", type_to_pytype(element))
        }
        ObjectType::Map(key_type, value_type) => {
            format!(
                "map({}, {})",
                type_to_pytype(key_type),
                type_to_pytype(value_type)
            )
        }
        ObjectType::Option(element) => {
            format!("opt({})", type_to_pytype(element))
        }
    }
}

fn type_info_to_python_type(info: &ObjectType, list_comment: bool) -> String {
    match info {
        ObjectType::U8
        | ObjectType::U16
        | ObjectType::U32
        | ObjectType::U64
        | ObjectType::I8
        | ObjectType::I16
        | ObjectType::I32
        | ObjectType::I64 => "int".to_string(),
        ObjectType::F32 | ObjectType::F64 => "float".to_string(),
        ObjectType::Bool => "bool".to_string(),
        ObjectType::String => "str".to_string(),
        ObjectType::Empty => "()".to_string(),
        ObjectType::Enum(name, _) => name.clone(),
        ObjectType::Struct(name, _) => name.clone(),
        ObjectType::Tuple(elements) => {
            let elems: Vec<String> = elements
                .iter()
                .map(|e| type_info_to_python_type(e, list_comment))
                .collect();
            format!("tuple[{}]", elems.join(", "))
        }
        ObjectType::List(size, element) => {
            let elem_str = type_info_to_python_type(element, list_comment);
            if list_comment {
                format!("list[{}]  # fixed size {}", elem_str, *size)
            } else {
                format!("list[{}]", elem_str)
            }
        }
        ObjectType::Vec(t) => {
            let elem_str = type_info_to_python_type(t, list_comment);
            format!("list[{}]", elem_str)
        }
        ObjectType::Map(key, value) => {
            let key_str = type_info_to_python_type(key, list_comment);
            let value_str = type_info_to_python_type(value, list_comment);
            format!("dict[{}, {}]", key_str, value_str)
        }
        ObjectType::Option(element) => {
            let elem_str = type_info_to_python_type(element, list_comment);
            format!("{} | None", elem_str)
        }
    }
}

fn order_structs(items: &Vec<(String, ObjectType)>, order: &mut VecDeque<String>) {
    for (_, item_type) in items {
        if let ObjectType::Struct(name, fields) = item_type {
            if !order.contains(name) {
                order.push_front(name.clone());
                order_structs(fields, order);
            }
        }
    }
}

pub fn generate<S: State>(path: impl ToString) -> Result<(), String> {
    let map = scripts::parse_states::<S>();
    let mut values_list = Vec::new();
    for (_, values) in map.iter() {
        for value in values {
            values_list.push(value.clone());
        }
    }
    let (enums, structs) = scripts::get_all_enums_struct(&values_list);
    let mut order_list = VecDeque::new();
    for (struct_name, items) in &structs {
        if !order_list.contains(struct_name) {
            order_list.push_front(struct_name.clone());
            order_structs(items, &mut order_list);
        }
    }

    let mut file =
        fs::File::create(path.to_string()).map_err(|e| format!("Failed to create file: {}", e))?;

    file.write_all(b"# Generated by build.rs, do not edit\n")
        .unwrap();

    if structs.len() > 0 {
        file.write_all(b"from dataclasses import dataclass\n")
            .unwrap();
    }

    file.write_all(b"from egui_states.server import StateServerCore")
        .unwrap();

    if enums.len() > 0 || structs.len() > 0 {
        file.write_all(b"\nimport egui_states.custom_types as cust")
            .unwrap();
    }

    file.write_all(b"\n").unwrap();

    for (enum_name, variants) in &enums {
        file.write_all(format!("\nclass {}(cust.FastEnum):\n", enum_name).as_bytes())
            .unwrap();
        for (name, value) in variants {
            let text = format!("    {} = {}\n", name, value);
            file.write_all(text.as_bytes()).unwrap();
        }
    }

    for struct_name in &order_list {
        let fields = &structs[struct_name];
        file.write_all(
            format!("\n@dataclass\nclass {}(cust.CustomStruct):\n", struct_name).as_bytes(),
        )
        .unwrap();

        if fields.len() == 0 {
            file.write_all(b"    pass\n").unwrap();
            continue;
        }

        for (name, typ) in fields {
            let py_type = type_info_to_python_type(typ, true);
            let text = format!("    {}: {}\n", name, py_type);
            file.write_all(text.as_bytes()).unwrap();
        }
    }

    Ok(())
}
