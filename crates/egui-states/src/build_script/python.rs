use std::collections::BTreeMap;
use std::collections::VecDeque;
use std::string::ToString;
use std::{fs, io::Write};

use egui_states_core::types::ObjectType;

use crate::State;
use crate::build_script::scripts;
use crate::build_script::state_creator::StatesCreatorBuild;
use crate::build_script::values_info::{InitValue, StateType};

fn type_to_pytype(type_info: &ObjectType) -> String {
    match type_info {
        ObjectType::U8 => "u8".to_string(),
        ObjectType::U16 => "u16".to_string(),
        ObjectType::U32 => "u32".to_string(),
        ObjectType::U64 => "u64".to_string(),
        ObjectType::I8 => "i8".to_string(),
        ObjectType::I16 => "i16".to_string(),
        ObjectType::I32 => "i32".to_string(),
        ObjectType::I64 => "i64".to_string(),
        ObjectType::F32 => "f32".to_string(),
        ObjectType::F64 => "f64".to_string(),
        ObjectType::Bool => "bo".to_string(),
        ObjectType::String => "st".to_string(),
        ObjectType::Empty => "emp".to_string(),
        ObjectType::Enum(name, _) => format!("enu({})", name),
        ObjectType::Struct(name, _) => format!("str({})", name),
        ObjectType::Tuple(vec) => {
            let elems: Vec<String> = vec.iter().map(|t| type_to_pytype(t)).collect();
            format!("tu([{}])", elems.join(", "))
        }
        ObjectType::List(size, element) => {
            format!("li({}, {})", type_to_pytype(element), size)
        }
        ObjectType::Vec(element) => {
            format!("vec({})", type_to_pytype(element))
        }
        ObjectType::Map(key_type, value_type) => {
            format!(
                "map({}, {})",
                type_to_pytype(key_type),
                type_to_pytype(value_type)
            )
        }
        ObjectType::Option(element) => {
            format!("opt({})", type_to_pytype(element))
        }
    }
}

fn type_info_to_python_type(
    info: &ObjectType,
    import: Option<&impl ToString>,
    list_comment: bool,
) -> String {
    match info {
        TypeInfo::Basic(name) => match *name {
            "String" => "str".to_string(),
            "bool" => "bool".to_string(),
            "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" => "int".to_string(),
            "f32" | "f64" => "float".to_string(),
            "()" => "".to_string(),
            _ => panic!("Unsupported basic type: {}", name),
        },
        TypeInfo::Tuple(elements) => {
            let elems: Vec<String> = elements
                .iter()
                .map(|e| type_info_to_python_type(e, import, list_comment))
                .collect();
            format!("tuple[{}]", elems.join(", "))
        }
        TypeInfo::Array(element, size) => {
            let elem_str = type_info_to_python_type(element, import, list_comment);
            if list_comment {
                format!("list[{}]  # size: {}", elem_str, size)
            } else {
                format!("list[{}]", elem_str)
            }
        }
        TypeInfo::Option(element) => {
            let elem_str = type_info_to_python_type(element, import, list_comment);
            format!("{} | None", elem_str)
        }
        TypeInfo::Struct(name, _) => match import {
            None => name.to_string(),
            Some(import) => {
                format!("{}.{}", import.to_string(), name)
            }
        },
        TypeInfo::Enum(name, _) => match import {
            None => name.to_string(),
            Some(import) => {
                format!("{}.{}", import.to_string(), name)
            }
        },
    }
}

fn order_structs(items: &Vec<(String, ObjectType)>, order: &mut VecDeque<String>) {
    for (_, item_type) in items {
        if let ObjectType::Struct(name, fields) = item_type {
            if !order.contains(name) {
                order.push_front(name.clone());
                order_structs(fields, order);
            }
        }
    }
}

pub fn generate<S: State>(path: impl ToString) -> Result<(), String> {
    let map = scripts::parse_states::<S>();
    let mut values_list = Vec::new();
    for (_, values) in map.iter() {
        for value in values {
            values_list.push(value.clone());
        }
    }
    let (enums, structs) = scripts::get_all_enums_struct(&values_list);
    let mut order_list = VecDeque::new();
    for (struct_name, items) in &structs {
        if !order_list.contains(struct_name) {
            order_list.push_front(struct_name.clone());
            order_structs(items, &mut order_list);
        }
    }

    let mut file =
        fs::File::create(path.to_string()).map_err(|e| format!("Failed to create file: {}", e))?;

    file.write_all(b"# Generated by build.rs, do not edit\n")
        .unwrap();

    file.write_all(b"from egui_states.server import StateServerCoreBase")
        .unwrap();

    if enums.len() > 0 || structs.len() > 0 {
        file.write_all(b"\nimport egui_states.custom_types import as cust")
            .unwrap();
    }

    for (enum_name, variants) in &enums {
        file.write_all(format!("\nclass {}(cust.FastEnum):\n", enum_name).as_bytes())
            .unwrap();
        for (name, value) in variants {
            let text = format!("    {} = {}\n", name, value);
            file.write_all(text.as_bytes()).unwrap();
        }
    }

    for struct_name in &order_list {
        let fields = &structs[struct_name];
        file.write_all(format!("\nclass {}(cust.CustomStruct):\n", struct_name).as_bytes())
            .unwrap();
        if fields.len() == 0 {
            file.write_all(b"    pass\n").unwrap();
            continue;
        }
        for (name, typ) in fields {
            let py_type = type_info_to_python_type(typ, None::<&String>, true);
            let text = format!("    {}: {}\n", name, py_type);
            file.write_all(text.as_bytes()).unwrap();
        }

        file.write_all(b"\n    def __init__(self,").unwrap();
        let elems: Vec<String> = fields
            .iter()
            .map(|(name, typ)| {
                let py_type = type_info_to_python_type(typ, None::<&String>, false);
                format!("{}: {}", name, py_type)
            })
            .collect();
        file.write_all(format!("{}) -> None:\n", elems.join(", ")).as_bytes())
            .unwrap();
        file.write_all(b"        pass\n").unwrap();
    }

    Ok(())
}
